---
layout: post
title: "DeepSeek Engram: 조건부 메모리 아키텍처가 여는 '스케일링의 또 다른 축'"
date: 2026-01-25 12:00:00 +0900
author: 정하성
categories: [Blog]
tags: [deepseek, engram, llm, moe, conditional-memory, ai-architecture, scaling, hbm, memory-hierarchy]
excerpt: "DeepSeek의 Engram 논문을 분석하여, 조건부 메모리가 MoE의 조건부 연산과 어떻게 상보적으로 작동하는지, 그리고 이것이 AI 인프라의 메모리 계층 구조에 어떤 산업적 함의를 갖는지 검토한다."
banner_image: "/assets/images/posts/2026-01-25-deepseek-engram.jpg"
---

![](/assets/images/posts/2026-01-25-deepseek-engram.jpg)

DeepSeek의 Engram 논문(arXiv:2501.07372)을 분석하여, 조건부 메모리(conditional memory)가 MoE의 조건부 연산과 어떻게 상보적으로 작동하는지, 그리고 이것이 AI 인프라의 메모리 계층 구조에 어떤 산업적 함의를 갖는지 검토해보려 한다.

## 왜 지금 조건부 메모리인가

대규모 언어 모델(LLM) 스케일링의 주류는 오랫동안 두 갈래로 정리되어 왔다. 첫째는 연산 스케일링으로, 연산을 늘려 더 많이 학습하는 방식이다. 둘째는 파라미터 스케일링으로, 파라미터를 늘리되 토큰당 활성 파라미터를 제한해 연산량을 묶는 접근이다. 후자의 대표가 Mixture-of-Experts(MoE)이며, MoE는 토큰별로 일부 전문가(FFN) 만 활성화하는 조건부 연산(conditional computation)으로 모델 총용량을 크게 늘리면서도 토큰당 FLOPs를 상대적으로 일정하게 유지한다.

Engram이 문제 삼는 지점은 "Transformer가 지식 조회를 위한 원시 정보를 갖고 있지 않다"는 구조적 결핍이다. 그 결과 모델 내부에 이미 '정적인 사실'로 자리 잡은 패턴을 매번 Attention과 FFN을 통해 단계적으로 재구성하게 되며, 이 과정이 초기 레이어의 순차적 깊이(depth)를 소모한다. 논문은 "Diana, Princess of Wales" 같은 다중 토큰 개체가 여러 레이어를 거치며 점진적으로 식별되는 과정을 예로 들며, 이를 "정적 조회 테이블을 런타임 계산으로 재구성하는 비효율"로 해석한다.

이 문제의식은 "언어 모델링이 실제로는 서로 성격이 다른 두 과업을 동시에 처리한다"는 관찰로 확장된다. 정적 지식/로컬 패턴 회수는 반복적이고 결정론적이어서 조회로 처리하는 것이 최적이며, 동적 조합 추론은 가변적이고 문맥 의존적이어서 계산으로 처리해야 한다. Engram의 핵심 전제는 정적 패턴 저장·회수는 계산이 아니라 조회로 처리할수록 효율적이며, 그 조회를 모델 아키텍처 내부(파라메트릭)로 끌어들여 MoE의 조건부 연산과 상보적으로 결합하면 새로운 스케일링 축이 열린다는 점이다.

이 관점은 "AI가 HBM만이 아니라 DRAM까지 '먹기' 시작할 수 있다"는 산업적 함의로 연결된다. Engram류 설계가 메모리 수요 구조를 흔들 수 있다는 문제의식이 있으며, 논문이 명시한 '호스트 메모리 오프로딩'과 '메모리 계층 활용'이 그러한 논의의 기술적 기반을 제공한다.

## Engram의 기술적 핵심과 혁신 지점

Engram은 논문에서 "조건부 메모리(conditional memory)"라는 독립적 희소성 축을 제안하며, 이를 N-gram 임베딩을 현대화한 모듈로 구현한다. 목표는 토큰 위치별로 로컬 컨텍스트(접미 N-gram)를 키(key)로 사용해 거대한 임베딩 테이블에서 상수 시간(O(1)) 조회를 수행하고, 그 결과를 현재 히든 스테이트와 '문맥 인식 게이팅'으로 융합하는 것이다.

Engram 조회는 "접미 N-gram → 결정적 해시 → 임베딩 테이블 인덱스"라는 전형적 해시 조회 구조로 설계되어 있다. N-gram 조합 공간을 직접 파라미터화하는 것은 불가능(조합 폭발)하므로, 해시 충돌을 완화하기 위해 N의 차수(예: 2-gram, 3-gram)별로 다중 해시 헤드(multi-head hashing)를 사용한다. 각 헤드는 압축된 N-gram을 소수 크기의 테이블 인덱스로 매핑하며, 곱셈·XOR 기반의 경량 해시로 구현된다.

중요한 현대화 포인트는 토크나이저 압축(tokenizer compression)이다. 일반적인 서브워드 토크나이저는 원문 복원에 최적화되어 "Apple"과 "␣apple"처럼 표면적으로 다른 토큰에 서로 다른 ID를 부여하는 경우가 잦다. Engram은 표면 변이를 정규화하고, 동치군을 하나의 캐노니컬 ID로 사상하는 사전 계산된 surjective mapping을 적용한다. 그 결과 128k 토크나이저에서 유효 어휘 크기가 약 23-24% 감소한다.(128k → 98k)

조회된 임베딩은 "정적 선험"이지만, 정적이라는 특성 때문에 다의성·해시 충돌로 인한 노이즈를 피하기 어렵다. 이를 해결하기 위해 현재 토큰 위치의 히든 스테이트를 Query로, 조회 임베딩을 Key/Value의 소스로 두는 형태의 스칼라 게이트(α)를 계산한다. RMSNorm을 Query/Key에 적용해 안정성을 확보하며, "현재 문맥과 조회된 메모리가 충돌하면 게이트가 0에 수렴해 노이즈를 억제"하는 메커니즘이다. 게이팅 이후에는 depthwise causal convolution을 추가하는데, 커널 크기 4, dilation을 최대 N-gram 차수로 설정하고 SiLU 활성화를 사용한다. 단, 구조 소거 실험에서 이 컨볼루션의 기여는 상대적으로 작게 관측되었다.

Engram은 "멀티브랜치 아키텍처(논문 기본 백본)"에 맞춰 결합 전략을 최적화한다. 브랜치별 게이팅 행동이 다를 수 있으므로 브랜치별 Key 프로젝션을 두고, 거대한 희소 임베딩 테이블과 Value 프로젝션은 공유한다. 이를 통해 여러 선형 프로젝션을 하나의 밀집 FP8 행렬곱으로 융합할 수 있어 현대 GPU에서 연산 활용도가 향상된다. 대규모 모델(27B/40B) 설정에서는 Engram 차원(d_mem) 1280, 해시 헤드 수 8, 사용 N-gram 차수 [2, 3], 삽입 레이어 [2, 15]를 사용한다.

전체 데이터 흐름을 요약하면: 토큰 시퀀스 → (정규화/압축) 캐노니컬 ID → 접미 2·3-gram 생성 → (결정적 해시) 인덱스 산출 → (거대 임베딩 테이블) O(1) 조회 → (concat) 메모리 벡터 구성 → (히든 스테이트 기반) 게이팅 α 적용 → (depthwise causal conv) 정련 → 잔차(residual)로 백본에 주입.

## 메모리 계층 관점에서의 의미: HBM을 '용량 계층'에서 분리하기

Engram의 시스템 레벨 주장은 단순히 "큰 테이블을 둔다"가 아니라, "테이블의 저장소(storage)와 계산(compute)을 분리(decouple)한다"는 데 있다. 논문은 GPU의 고대역폭 메모리(HBM) 용량 제약이 메모리-증강 모델 스케일링의 병목이 되기 쉽다고 전제하고, Engram의 결정적 조회 인덱스가 이 병목을 구조적으로 완화한다고 주장한다.

MoE 라우팅은 런타임 히든 스테이트에 의존하여 주소가 결정되므로 프리패치가 어렵다. 반면 Engram 조회는 입력 토큰 시퀀스만으로 사전 계산이 가능하여 프리패치가 가능하다. 이 결정성이 추론 시점에 "프리패치-오버랩(prefetch-and-overlap)"을 가능하게 한다. 앞쪽 Transformer 블록의 계산이 진행되는 동안 호스트 메모리(예: CPU DRAM)에 있는 Engram 임베딩을 PCIe를 통해 비동기적으로 가져오고, GPU 계산과 통신을 겹쳐 실행할 수 있다.

레이어 삽입 위치에는 트레이드오프가 있다. 너무 이른 삽입은 게이팅 Query가 충분히 문맥화되지 않아 정밀도가 저하되고, 너무 늦은 삽입은 정적 패턴 재구성 비용을 이미 백본이 지불해버린 뒤라 모델링 이득이 감소한다. 논문은 이를 "하드웨어-알고리즘 코드자인" 문제로 명시한다.

논문은 N-gram 접근이 Zipf 분포를 따른다는 점을 근거로 다계층 캐시 구성을 제안한다. HBM이나 호스트 DRAM에는 고빈도 패턴을 저장하여 빠른 접근을 가능하게 하고, NVMe SSD 등에는 롱테일을 저장하여 느리지만 대용량을 확보한다. 이를 통해 "거대한 메모리 용량 확장"과 "유효 지연의 최소화"를 동시에 추구한다.

HBM은 AI 가속기에서 대역폭을 제공하는 핵심 부품이지만, 용량 확대는 상대적으로 비싸고 복잡하다. JEDEC의 HBM3 표준도 TSV 스택과 다양한 용량 옵션을 언급하지만, "고비용 고집적 패키징"의 성격을 벗어나지 못한다. Engram이 제안하는 역할 분담은 HBM을 대역폭 계층으로, 호스트 DRAM(+ 더 느린 계층)을 용량 계층(정적 지식 저장소)으로 두는 것이다. 이는 "AI가 DRAM 수요를 구조적으로 끌어올릴 수 있다"는 주장의 기술적 고리가 된다. 다만 실제 수요 전환은 모델 채택 속도, 서빙 아키텍처(PCIe/CXL), 메모리 가격, 그리고 '대용량 테이블 오프로딩이 실제 제품 지연·비용에서 어떤 이득을 주는가'에 의해 결정되므로, 산업적 결론을 단정하는 것은 위험하다.

## 성능 평가 분석: "더 많은 지식"이 아니라 "더 많은 추론"이 오른 이유

Engram 논문의 설득력은 단순히 "지식 문제(MMLU 등)에서 점수가 올랐다"에 있지 않다. 저자들이 강조하는 것은 오히려 추론·코드·수학에서의 개선 폭이 더 크며, 그 이유를 "네트워크 유효 깊이(effective depth)의 확보"로 설명한다.

논문은 총 파라미터와 FLOPs 제약 하에서 희소 용량을 MoE 전문가와 Engram 메모리에 어떻게 배분할지를 "Sparsity Allocation" 문제로 정의한다. P_act(활성 파라미터)는 토큰당 훈련 FLOPs를 결정하고, P_sparse(비활성/희소 파라미터)는 계산을 크게 늘리지 않고 확장 가능하다. Engram은 토큰당 조회 슬롯 수가 상수이므로, 테이블의 슬롯 수를 늘리면 P_sparse를 증가시키면서도 토큰당 FLOPs는 크게 늘리지 않는 스케일링 레버로 작동한다.

핵심 실험 결과는 U자형 관계를 보여준다. C=6×10²⁰ FLOPs(약 10B 레짐)에서 ρ(MoE 비중)가 100%(순수 MoE)일 때 검증 손실은 1.7248이고, ρ가 약 80%(최적점)일 때 검증 손실은 1.7109로 Δ = -0.0139의 개선을 보인다. 결론적으로 희소 예산의 약 20%–25%를 Engram에 재할당할 때 최적이며, 최적점이 ρ≈75%–80% 범위에서 안정적으로 관측된다. 순수 MoE(ρ→100%)는 정적 패턴을 '계산으로 재구성'해야 하므로 깊이와 연산을 낭비하고, Engram 위주(ρ→0%)는 조건부 연산 용량 부족으로 동적 추론이 무너진다. 이는 "정적 지식 조회와 동적 추론은 대체재가 아니라 보완재"임을 보여준다.

대규모 사전학습 벤치마크 결과를 보면, 262B 토큰 학습과 활성 파라미터 3.8B 고정 조건에서 Dense-4B(4B 밀집 베이스라인), MoE-27B(26.7B 순수 MoE), Engram-27B(26.7B, MoE에서 일부를 Engram 메모리 5.7B로 재배치), Engram-40B(40B 확장 버전)를 비교했다. Table 1 기준으로 Engram-27B는 MoE-27B 대비 Pile loss -0.010, Validation loss -0.012, MMLU +3.0, CMMLU +4.0, BBH +5.0, ARC-Challenge +3.7, DROP +3.3, HumanEval +3.0, GSM8K +2.2, MATH +2.4의 개선을 보인다. 주목할 점은 지식형 점수 상승뿐 아니라 BBH, ARC-Challenge, HumanEval, MATH 같은 "복합 추론·절차적 일반화" 성격의 벤치마크에서도 일관된 개선이 나타난다는 것이다.

> 참고: 논문 초록은 "MMLU +3.4"라고 요약하지만, Table 1의 MoE-27B(57.4) 대비 Engram-27B(60.4)는 +3.0이다. 초록 수치는 다른 베이스라인(예: 동일 FLOPs Dense 모델) 대비이거나 평가 설정 차이일 가능성이 높다. 실무에서는 Table 기반 수치를 기준으로 해석하는 것이 안전하다.

Engram은 "로컬 의존성은 조회로 넘기고, attention은 글로벌 컨텍스트에 집중"할 수 있어 장문 과업에 유리하다. Table 2 주요 결과에서 MQ NIAH(Multi-Query Needle-in-a-Haystack)는 MoE-27B 84.2에서 Engram-27B 97.0으로 +12.8, VT(Variable Tracking)는 77.0에서 89.0으로 +12.0의 개선을 보인다. 이는 "단순히 메모리를 늘려 사실을 더 넣었다"가 아니라, attention의 유효 용량을 글로벌 관계에 재배치했다는 구조적 설명과 맞물린다.

논문은 "Engram이 초기 레이어의 정적 재구성 부담을 덜어 유효 깊이를 늘린다"는 가설을 LogitLens와 CKA로 뒷받침한다. LogitLens 기반 KL divergence 분석에서 Engram 변형이 초기 블록에서 더 빠르게 예측으로 수렴하는 경향을 보이며, CKA 유사도에서 Engram-27B의 5번째 레이어 표현이 MoE 베이스라인의 약 12번째 레이어 표현과 가장 잘 정렬된다. 즉 동일한 레이어 인덱스에서 더 '깊은 수준'의 표현이 형성된다. 이 메커니즘 설명은 Engram의 성능 이득을 지식 조회 성능에만 귀속시키지 않고, "추론을 위한 깊이를 확보했다"는 구조적 원인으로 확장하는 데 핵심 역할을 한다.

## 산업적·전략적 함의

Engram의 산업적 함의는 기술 논문치고 매우 직접적이다. 저자들은 "인프라를 고려한 효율(infrastructure-aware efficiency)을 1급 설계 원칙으로 둔다"고 표현한다.

서버·가속기 설계 관점에서 첫째, 메모리 용량 확장 방식이 변화한다. 기존에는 "GPU HBM 증설" 중심이었다면, Engram 이후에는 "호스트 메모리/스토리지 계층 활용" 중심으로 부분 이동이 가능하다. 오프로딩 실험 결과, 100B 파라미터 임베딩 테이블을 전부 호스트 DRAM에 두고도 throughput 페널티가 최대 2.8% 수준(8B dense 백본: 6315.52 tok/s → 6140.02 tok/s)이었다. 이는 '완전 최적화'가 아니라, 모든 조회가 PCIe를 타도록 강제한 보수적 실험이다. 둘째, 인터커넥트 경쟁의 새로운 차원이 열린다. 단순 대역폭 경쟁을 넘어 "프리패치 가능한 패턴 + 오버랩 가능한 실행 스케줄"을 얼마나 잘 지원하는가가 중요해지며, DMA/프리패치 엔진, 버퍼링 전략, 커널 스케줄링이 구조적으로 중요해진다.

논문 자체에서 CXL을 직접 언급하지는 않지만, Engram의 설계 철학이 CXL과 정합적이라는 분석이 가능하다. CXL은 프로세서·메모리 확장·가속기를 위한 캐시 일관성 인터커넥트로, 메모리 확장과 풀링을 핵심 용례로 삼으며 CXL 2.0/3.x에서 스위칭과 메모리 풀링 논의가 강화되고 있다. Engram의 결정적 주소 지정 + 다계층 캐시라는 설계 철학이 CXL 기반 메모리 확장/풀링과 정합적이며, "호스트-가속기 사이의 대용량 테이블을 더 유연하게 붙인다"는 방향성과 맞닿아 있다.

공급망과 비용 구조에 대해서는 "HBM이 절대적으로 부족하니 DRAM으로 우회"라는 프레임보다 "HBM은 대역폭 계층으로 남고, 용량 계층은 DRAM/스토리지로 분리해 확장"이라는 프레임이 더 정확하다. HBM 수요가 줄어든다기보다, '모델 용량 확대의 한계선'을 HBM 용량이 아니라 시스템 전체 메모리 계층으로 옮기는 효과다. Engram은 "같은 활성 파라미터(=연산 예산)로 더 많은 총 파라미터를 밀어 넣는 방법"을 제안하여, GPU 시간을 덜 쓰면서(또는 같은) 지식 용량을 키우는 방향이며, 추론 비용(TCO)의 일부를 'GPU FLOPs'에서 '메모리/인터커넥트/캐싱 엔지니어링'으로 이동시킨다. 단, 실제 비용 절감이 되려면 오프로딩/캐싱의 구현 복잡도와 운영 리스크가 GPU 비용 절감분을 상쇄하지 않아야 하며, 상용 구현 난이도는 여전히 미지수다.

## 스케일러빌리티와 한계에 대한 비판적 분석

Engram은 "새로운 축"이라는 표현만큼 강력한 장점을 보이지만, 동시에 뚜렷한 제약이 존재한다.

해시 기반 N-gram 조회는 본질적으로 충돌을 내포한다. 다중 해시 헤드와 문맥 게이팅은 완화하지만 완전한 해결책은 아니며, 다의성과 문맥 의존이 강한 토큰에게 "로컬 N-gram은 강한 키가 아니다". 설계적 대응으로 게이팅을 Query(히든 스테이트) 기반으로 두었고, 게이팅 시각화에서 다중 토큰 개체·상투구에서 강한 활성화가 관측된다. 즉 "정적이고 상투적인 의존성"에 강하고, 문맥적으로 불안정한 패턴에는 게이트를 낮춰 노이즈를 억제한다.

레이어 삽입 위치의 제약도 있다. 단일 삽입 스윕 결과 레이어 2가 최적이며, 더 깊은 레이어로 갈수록 효능이 감소한다. 한 번의 attention만으로도 게이팅에 쓸 정도의 문맥화가 형성되면서 동시에 아직 충분히 이르기 때문에 로컬 재구성을 대체할 수 있기 때문이다. 스케일 확대 시에는 대규모 모델에서 레이어 스케줄링, 커널 배치, 프리패치 윈도우 설계가 복잡해지며, 시스템 조건(PCIe 세대, NUMA, CPU 메모리 대역폭, 컨커런시 등)에 따라 "최적 삽입 레이어"가 달라질 가능성이 있어 일반화된 가이드라인은 아직 초기 단계다.

학습 인프라 관점의 비용도 고려해야 한다. 훈련 시점에 거대한 임베딩 테이블을 GPU들에 샤딩하고, Forward에서 활성 row를 모으기 위해 All-to-All 통신을 사용한다. "테이블이 매우 커질수록 통신·샤딩·옵티마이저 상태 관리"가 핵심 비용이며, '희소 임베딩을 얼마나 고성능으로 업데이트할 수 있는가'는 제품화에서 가장 큰 리스크 중 하나다.

지식 업데이트와 편집 가능성도 열린 질문이다. Engram은 파라메트릭 메모리로서 "학습된 지식이 테이블에 박힘"이다. RAG/RETRO/REALM 같은 접근은 지식을 외부 스토어(비파라메트릭)에 저장하여 편집 가능성이 높고 인덱스 업데이트로 최신성 적응이 가능한 반면, Engram은 모델 내부에 저장하여 편집 가능성이 제한적이고 재학습이 필요하다. "Engram 테이블을 어떻게 안전하고 국소적으로 업데이트할 것인가", 충돌·정규화·캐시 일관성을 포함한 편집 프로토콜은 별도 연구 과제다.

## MoE·RAG·기타 메모리 스케일링과의 비교

Engram을 가장 정확히 위치시키는 비교 축은 "어디에 지식을 저장하고, 어떤 비용으로 꺼내며, 시스템에서 어떻게 숨길 수 있는가"이다.

Dense Transformer는 레이어/차원/파라미터 증가를 핵심 스케일링 레버로 삼아 토큰당 연산 비용이 증가하고, 지식은 가중치 전반(특히 FFN)에 저장되며, attention·FFN 기반 접근 패턴을 사용한다. 단순한 서빙/학습이 장점이지만 비용 폭증과 HBM 용량 병목이 구조적 약점이다. MoE는 전문가 수 증가(조건부 연산)를 레버로 삼아 토큰당 연산 비용은 Top-k 활성으로 제한하고, 지식은 전문가 파라미터에 저장되며, 라우팅이 런타임 히든에 의존한다. 총 파라미터를 대폭 확장할 수 있지만 통신/라우팅/로드밸런싱이 복잡하다. RAG/RETRO/REALM은 외부 코퍼스/인덱스/리트리버를 레버로 삼아 모델 연산 + 검색 비용이 들고, 지식은 외부 스토어(비파라메트릭)에 저장되며, 검색 결과에 의존(비결정적 가능)한다. 최신성·편집·도메인 적응이 장점이지만 검색 품질·지연·운영이 복잡하다. Engram은 거대 N-gram 테이블(조건부 메모리)을 레버로 삼아 O(1) 조회 + 소규모 융합 비용이 들고, 지식은 모델 내부 메모리 테이블에 저장되며, 입력 토큰 기반 결정적 주소 지정을 사용한다. 오프로딩/프리패치 가능하고 유효 깊이를 확보하는 것이 장점이지만 해시 충돌, 로컬 키 한계, 업데이트 난제가 구조적 약점이다.

Engram의 최적 포지션은 "MoE와 결합된 하이브리드"다. U자형 할당 법칙이 직접 뒷받침하며, 순수 MoE나 순수 Engram이 최적이 아닌 이유를 정량적으로 보여준다.

## 향후 과제

논문은 결론에서 조건부 메모리를 "차세대 희소 모델의 필수 원시"로 전망한다. 그러나 이 전망이 현실이 되려면 다음 과제가 해결되어야 한다.

첫째, 메모리 계층을 실제로 활용하는 상용 구현이 필요하다. 논문은 Zipf 기반 캐시 계층과 PCIe 프리패치 오버랩을 제안하지만, 프로덕션 서빙(VLLM 계열, 텐서 병렬/파이프라인 병렬, KV 캐시 경쟁)에서 이를 일반화하는 것은 별도 공학 문제다.

둘째, 메모리의 편집과 안전 문제가 있다. Engram이 사실 지식 저장소로 강하게 작동한다는 증거(Engram 출력 억제 시 TriviaQA 등에서 29–44%만 성능 유지)가 제시된 만큼, 이 테이블의 업데이트·삭제·감사 가능성은 실무 리스크로 직결된다.

셋째, "로컬 패턴 조회"를 넘어선 확장이 필요하다. 현재 설정은 [2,3]-gram 중심이며, 4-gram은 고정 예산에서 비효율적이라고 보고됐다. 더 큰 메모리 스케일에서 고차 N-gram이 유의미해질지, N-gram 키를 넘어 더 풍부한 결정적 키 설계(예: 압축된 컨텍스트 해시, structured key)가 가능한지는 열린 질문이다.

넷째, 차세대 메모리 인터커넥트와의 결합이다. 논문은 PCIe를 사용하지만, 결정적 주소 지정이라는 특성은 CXL의 메모리 확장/풀링과 설계 철학적으로 정합적이다. Engram이 주는 압력은 "가속기에게 필요한 것은 HBM 대역폭 + 외부 계층의 대용량"이며, 이는 CXL 계열이 겨냥하는 방향과 닮아 있다.

## 참고자료

[Conditional Memory via Scalable Lookup: A New Axis of Sparsity for Large Language Models](https://arxiv.org/abs/2601.07372)

[Engram GitHub 공개 저장소](https://github.com/deepseek-ai/Engram)

[Outrageously Large Neural Networks: The Sparsely-Gated Mixture-of-Experts Layer](https://arxiv.org/abs/1701.06538)

[HBM3 표준 발표](https://www.jedec.org/news/pressreleases/jedec-publishes-hbm3-update-high-bandwidth-memory-hbm-standard)

[About CXL](https://computeexpresslink.org/about-cxl/)

[CXL Memory Pooling and Sharing](https://computeexpresslink.org/blog/explaining-cxl-memory-pooling-and-sharing-1049/)
