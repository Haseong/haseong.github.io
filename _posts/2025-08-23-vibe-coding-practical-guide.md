---
layout: post
title: "바이브 코딩 실전 가이드"
date: 2025-08-23 11:54:17 +0900
author: 정하성
categories: [Blog]
tags: [blog, korean]
excerpt: "(요약 생성 실패)"
banner_image: "/assets/images/posts/2025-08-23-시대가-바뀌었다-우리는-눈치챘는가.jpg"
---

![](/assets/images/posts/2025-08-23-시대가-바뀌었다-우리는-눈치챘는가.jpg)

바이브 코딩(Vibe Coding): AI 도구와 대화하며 함께 코드를 작성하는 새로운 개발 패러다임. 개발자가 아키텍트와 지휘자 역할을 하고, AI가 실제 구현을 담당하는 협업 방식.

## 시대가 바뀌었다, 우리는 눈치챘는가

"구석기, 신석기, 청동기, 산업, 정보화" 이런 시대의 흐름이 있었고 각 시대마다 혁명의 도구들이 발명되면서 전 시대와는 확연히 구분되는 생산성 향상을 가져왔다. 당시에는 몰랐어도 후대에 가서야 그게 혁명이었다는 것을 눈치챘고 시대를 구분지어왔다.

지금 우리가 겪고 있는 이 시기 또한 엄청난 도구들이 나오고 있고 이 도구들은 AI라는 구분으로 묶을 수 있으며 우리는 이 시기를 AI 시대라고 구분지을지 모른다. 아니, 이미 구분짓고 있다. 도구들이 새로 생기고 발명되면 생산성의 향상을 가져왔는데, 이런 생산성이 우리에게 풍요를 주었고 그 시기마다 인구와 인간의 평균 지적 수준의 향상을 가져왔다.

그럼 지금 우리가 AI라는 도구로 인하여 발생될 추가적 생산성은 엄청날 것이고 이것을 잘 쓰는 사용자가 이 생산성을 독식하고 부를 가져갈 가능성이 높다. 전반적인 생산 주제로 다 나열하기에는 너무 방대하기에 AI와 가장 근접한 IT에서의 가장 생산성이 높은 도구인 바이브 코딩을 가지고 이야기해보려고 한다.

## 우리는 기다려왔는지 모른다, 인간이 지적인 활동조차 대신할 존재를

우리는 어쩌면 기다려왔는지 모른다. 인간이 지적인 활동조차 대신할 존재를. 그 시간이 너무 일찍 와버린게 아닌가 싶은 착각이 들 정도로 지금의 소프트웨어 코딩계의 변화는 심한 변화를 맞이하고 있다.

나는 20년 넘게 코딩을 해왔다. 나는 여러 IDE와 C, C++, Go, Node.js, Python, Swift, Kotlin, Java 등 다양한 언어와 환경을 접해왔다. 그동안 IDE는 계속 똑똑해졌다. 자동완성이 생기고, 리팩토링 기능이 추가되고, 코드 분석이 실시간으로 이루어졌다. 하지만 이 모든 것은 결국 '도구'였다. 코드를 작성하는 주체는 여전히 나였다.

그런데 2023년부터 뭔가 달라졌다. Cursor를 처음 써봤을 때의 충격은 아직도 생생하다. 내가 함수명만 적었는데 전체 함수를 완성해버렸다. 처음엔 신기했다. 그러다 무서워졌다. '이거 내 일자리 없어지는 거 아냐?'라는 생각이 들었다.

하지만 실제로 써보니 달랐다. AI는 나를 대체하는 게 아니라 나를 증폭시켰다. 예전에 하루 걸리던 일이 2시간이면 끝났다. 일주일 프로젝트가 하루 만에 완성됐다. 이게 바로 바이브 코딩의 힘이다.

물론 AI에도 한계가 있다. 특정 도메인의 깊은 지식을 찾는 방법을 알아서 생각하지 못하고, 때로는 구식 패턴으로 코드를 생성한다. 하지만 이런 한계를 이해하고 적절히 활용하면 생산성은 극대화된다.

## 도구가 바뀌었는데 왜 우리는 그대로인가

도구가 바뀌었음에도 불구하고 새로운 도구를 거부하는 사람은 항상 존재해왔으며, 이런 거부는 비전문가보다 전문가 그룹에서 더 많이 있어왔다. 대표적으로 1차 산업혁명이 나오고 방직 기계의 발명으로 맨체스터의 노동자들이 자기들의 직장을 잃는다는 공포에 기계를 부수는 러다이트 운동을 일으켰으며, 이러한 피해는 상당했지만 시대의 흐름을 막을 수는 없기에 이런 노동자들은 방직기계를 만들고 수리하며 기계가 생산한 것들을 정리하는 노동자로 변화되었다.

그럼 이런 동일한 현상이 소프트웨어 코딩에도 동일하게 이루어질 것이며 이런 상황에서 할 수 있는 일이 무엇인지 소프트웨어 엔지니어들은 생각을 해봐야 한다. 새로운 도구를 거부하는 것은 당연히 기존의 방식을 도구가 대체하기에 필요 없는 노동이 될 것이고 단시간에 대체될 가능성이 높다.

이런 일이 일어날 수 있다. 10년차 시니어 개발자가 "AI 코드는 믿을 수 없어"라며 거부하다가 프로젝트에서 밀려났다. 반면 3년차 주니어가 AI 도구를 적극 활용해서 시니어보다 더 빠르게 기능을 구현했다. 회사는 누구를 더 선호할까? 답은 명확하다.

하지만 그 도구를 도우는 일들이나 도구를 잘 활용하는 일들은 언제나 역사의 흐름과 함께하기에 더 높은 생산성을 주기에 부의 창출로 이루어졌다. 그럼 개발자들이 바이브 코딩 도구를 가지고 생산성을 극대화하는 방법에 대해 얘기해보고자 한다.

## 개발 비용이 거의 공짜가 되어버렸다

소프트웨어 개발이라는 것은 서비스를 제공하는 프로그램을 만드는 일이다. 그럼 이런 서비스를 개발하는 방식을 바꾸는 도구와 함께 어떤 형태로 바꾸어야 가장 효율적인지는 지금의 개발하는 형태를 보면 알 수 있다. "기획 → 디자인 → 개발 → 유지보수" 이렇게 단순화시켜서 볼 수 있다.

기획, 디자인, 개발 순서에서 개발이 맨 뒤에 있는 이유는 앞의 것들보다 뒤의 개발이 비용이 비싸서다. 기획으로 나온 것을 디자인으로 만들고 디자인된 걸 개발로 바꾸는 것들은 뒤로 갈수록 비용이 비싸서라고 보면 된다. 기획이 가장 싸고 그다음 디자인 그다음이 개발이라는 얘기다.

근데 지금 바이브 코딩으로 인하여 개발을 생산하는 비용이 매우 낮아졌다. 이런 개발비용이 싸졌으니 굳이 개발을 맨 뒤에 놓을 필요가 없다. 집을 바로 짓는 비용이 비싸서 설계도를 요리조리 바꾸면서 공을 들였는데 집을 짓는 비용이 매우 싸졌다고 가정을 해보자. 그럼 우선 집을 한번 지어보고 마음에 안들면 바로 부서버리고 다시 지으면 된다. 오히려 설계를 통하여 머리속에서 시뮬레이션하면서 요리조리 생각하는 게 더 비용이 많이 든다면 굳이 그럴 이유가 없다.

마찬가지로 개발의 생산비용이 말도 안 되게 낮아진 상태다. 경우에 따라서는 20년 전 대비 최대 1/100 수준의 비용으로 개발이 가능하다. 예전에 팀 5명이 6개월 걸려서 만들던 프로젝트를 이제 혼자서 일주일이면 만들 수 있는 경우도 있다. 이게 과장이 아니라 실제로 경험한 것이다.

## 한 번에 완벽한 건 없다 - Task 쪼개기의 중요성

완벽한 어플리케이션이 한 번에 나올 거라는 기대는 착각이다. 서비스 개발은 단순한 100줄 코드가 아니기에 복잡도가 높다.

LLM이 일을 잘하게 하려면 Cursor나 Claude Code에 일을 잘게 쪼개서 Task로 만들어야 한다. Task Master나 Shrimp Task Manager 같은 도구를 활용하면 효과적이다. 거대한 요구사항을 한 번에 던지면 디테일이 빠지거나 원하는 결과가 나오지 않는다.

효과적인 Task 분할 방법:

- 전체 프로젝트를 기능 단위로 나누기
- 각 기능을 세부 구현 단계로 쪼개기
- 한 번에 하나의 명확한 목표만 제시
- 각 Task 완료 후 검증하고 다음 단계 진행

그렇다고 아무 컨셉도 없이 바로 코딩을 치라는 얘기는 아니다. 우선 컨셉부터 잡을 필요가 있다. 내가 만드려는 것에 대해 ChatGPT나 Claude를 통하여 아이디어를 주입하여 디테일을 뽑아낸다. 이런 디테일을 뽑아내는 것이 매우 중요하다.

AI 도구는 쓰레기를 넣으면 쓰레기가 나오기에 대충 질문해서는 안 된다. 짧은 내용인 것은 문제가 되지 않는다. 하지만 최대한 명확하고 집요한 질문을 하고 그걸 계속 LLM과 얘기하여 LLM과 내가 대화를 통하여 만드려는 디테일을 알아차리게 하는 게 중요하다.

예를 들어보자. "쇼핑몰 만들어줘"라고 하면 안 된다. "Next.js 14 App Router를 사용하고, Supabase로 백엔드를 구성하며, Stripe로 결제를 처리하는 반응형 쇼핑몰을 만들어줘. 상품 카테고리는 의류, 신발, 액세서리로 구분하고, 관리자 페이지에서 상품 CRUD가 가능해야 해. 그리고 장바구니는 로컬 스토리지가 아니라 DB에 저장해서 로그인하면 다른 기기에서도 볼 수 있게 해줘"라고 해야 한다.

이런 내용들이 만들어지면, PRD를 작성하고 여기서 나온 PRD를 통하여 컨셉을 하나 뽑아달라고 하여 디자인 컨셉을 뽑아야 한다. 이때 가상의 이미지가 중요할 수도 있는데 PRD에서 나온 내용을 간추려서 내가 생각한 하나의 이미지를 잘 뽑아야 한다.

이런 이미지가 뽑아져 나오면 Cursor나 Claude Code를 통하여 내가 원하는 형태의 웹이나 앱의 UI/UX를 생성해달라고 하고 여기에 PRD도 같이 설명해줘서 첫 어플리케이션 버전을 만들어야 한다.

## 코드 버리기 철학 - 바이브 코딩의 핵심

바이브 코딩에서 가장 중요한 마인드셋은 '버리고 다시 만들기'다. 개발 비용이 극도로 낮아진 지금, 완벽을 추구하며 수정하기보다 과감히 버리고 새로 만드는 것이 더 효율적이다.

나는 동일한 개발을 3-4번씩 한 적이 있었는데, 이유는 마음에 들지 않아서 기존에 만들었던 코드를 다 지우고 다시 만드는 일을 여러 번 하기도 한다. 중요한 일일수록 이렇게 하는 게 습관에 들어가 있다.

처음 하면 한 달 걸리는 프로젝트가, 코드를 버리고 다시 하면 일주일, 또 버리면 2일이 걸리는 경험이 흔하다. 왜일까? 테크닉이 좋아져서가 아니다. 어떤 구조로 만들어야 하는지 명확해지기 때문이다.

바이브 코딩으로 나온 결과를 전반적으로 검토해야 한다:

- 구조와 아키텍처가 적절한가?
- 라이브러리 조합이 최적인가?
- 더 나은 방식이 떠오르는가?

마음에 들지 않으면 고치지 말고 지워라. 이게 기존 코딩과 완전히 다른 접근법이다.

실제 예를 들어보자. 최근에 SaaS 제품을 하나 만들었다. 처음엔 전통적인 방식으로 시작했다. React + Express + PostgreSQL 조합으로 말이다. 2주 정도 개발했는데 뭔가 마음에 안 들었다. 코드가 너무 많았고, 보일러플레이트가 지저분했다.

과감하게 다 버리고 Next.js + Supabase로 다시 시작했다. 3일 만에 2주 작업한 것보다 더 나은 결과물이 나왔다. 인증, 실시간 기능, 파일 업로드까지 모두 포함해서 말이다.

## 개발 아키텍처, 이제는 AI 친화적이어야 한다

바이브 코딩에서 무엇보다 중요한 게 개발 조합이다. 이를 개발 아키텍처라고도 할 수 있다. 우리가 개발을 진행할 때 이 구조가 얼마나 중요한지는 다 알 것이다. 바이브 코딩에 있어서는 이게 더욱 중요해졌다. 왜냐면 어떤 아키텍처로 만드냐에 따라 개발 속도가 매우 차이가 난다. 한마디로 바이브 코딩에서의 핵심은 속도로 보는데 이는 바로 비용이다. 비용을 절약하려고 하는 게 바이브 코딩인데 비용이 오히려 상대적 증대되는 경우로도 갈 수 있다는 것이다.

그에 대해 몇 가지 아키텍처의 요소들을 소개하고자 한다. Supabase, Vercel Cloud, GCP Cloud Run, AWS App Runner가 이 요소들이다.

Supabase는 원래 Google의 Firebase의 lock-in 효과를 걷어내기 위해 Firebase를 대체하고자 오픈소스로 만들어졌는데, 이를 SaaS 요구에 따라 Supabase SaaS가 만들어졌다. Supabase를 잘 사용하면 RLS를 통하여 2-Tier 형태로의 코딩이 가능해져 코드의 양을 많이 줄일 수 있다.

실제로 사용해보니 정말 편하다. 예전에는 백엔드 API를 만들고, 인증 미들웨어를 작성하고, 데이터베이스 쿼리를 짜고, 에러 핸들링을 하고... 이런 것들이 전부 Supabase에서는 몇 줄로 끝난다. RLS(Row Level Security) 정책을 한 번 설정해두면, 프론트엔드에서 직접 데이터베이스에 접근해도 안전하다. 이게 얼마나 큰 차이인지 모른다.

그리고 AWS, GCP를 통하여 VM을 이용할 수 있다고 하더라도 서버 관리를 해야 된다는 것은 이후 지속 관리에 있어서도 귀찮은 일들이 많다. Vercel Cloud를 이용하면 Next.js로 만들어진 경우 원클릭으로 서버리스 환경에 배포가 가능하다.

GCP Cloud Run, AWS App Runner을 이용하면 어떤 언어로 만들어지든 컨테이너 형태로 패키징을 하면 서버리스로 어플리케이션이 배포되고 관리에 대한 부분이 사라져서 매우 편하다.

이런 게 그렇게 중요한 건가라고 생각할 수도 있다. 근데 해보면 안다. 매우 중요하다. 요리에서 최고의 맛을 내는 데는 각 재료마다 1점씩 올려서 100점을 만들듯이 아무리 작은 것이라고 할지라도 하나씩 포인트를 올려서 서비스의 완성도를 올려야 한다.

최근 프로젝트 사례: Supabase + Cloud Run + Next.js 조합으로 구성했다. 배포는 git push만 하면 자동으로 된다. 데이터베이스 마이그레이션도 Supabase CLI로 간단하게 처리한다. 서버 관리? 그런 거 없다. 스케일링? Cloud Run이 알아서 한다. SSL 인증서? 자동이다. 이 모든 게 무료 티어에서도 가능하다.

## 토큰을 아껴라, 그게 곧 돈이다

바이브 코딩에서의 핵심은 LLM인데, LLM의 가장 큰 약점은 토큰에 대한 제한이 있다는 것이다. 그래서 무엇보다 토큰을 효과적으로 사용하는 것이 매우 중요하다.

기본적으로 바이브 코딩을 영어로 할 수 있으면 좋다. 왜냐면 한국어는 영어 대비로 2배 정도의 토큰을 소비한다. 그러므로 바이브 코딩을 할 때 영어로 하면 더 많은 대화를 축적하면서 코딩을 할 수 있으니 코드의 퀄리티와 비용에서 훨씬 유리하다.

기반이 되는 md 문서를 영어로 작성한다. cursor.rules, claude.md와 같은 문서는 Cursor와 Claude Code에서 자동으로 불러와서 프롬프트로 지정하고 사용하게 된다. 이 문서를 영어로 작성하는 것이 토큰을 절약하는 데 매우 중요하다.

예를 들어 cursor.rules 파일의 효과적인 작성법:

```
You are an expert full-stack developer.
Tech stack: Next.js 14, TypeScript, Tailwind CSS, Supabase
Code style: Clean, minimal, functional
Always use arrow functions
Prefer async/await over promises

```

이게 한국어로 쓰면 토큰이 2배다. 한 달이면 토큰 비용만 개발자 한 명에 수십만 원 차이가 날 수 있다.

그리고 중간중간 대화의 clear 처리를 하거나 compact 기능을 사용하여 불필요한 맥락 정보를 넣지 않아야 한다. 지금 코딩에 필요한 정보만 토큰으로 전달하는 기법이 중요하다.

토큰 수를 높게 쓰는 언어를 지양한다. 대표적으로 Java 같은 언어는 Kotlin 대비로 2-3배의 코드의 양이 필요하다. 코드 양이 크다는 것은 단순히 IDE에서 자동으로 코드를 생성해줄 수 있으니 상관없던 시대와 달라진다는 이야기다. 굳이 토큰 수를 많이 잡아먹는 언어로 만들 이유가 없다.

Java 코드 예시:

```java
public class UserService {
    private final UserRepository userRepository;
    
    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
    
    public User getUserById(Long id) {
        return userRepository.findById(id).orElse(null);
    }
}

```

Kotlin으로 같은 코드:

```kotlin
class UserService(private val userRepository: UserRepository) {
    fun getUserById(id: Long) = userRepository.findById(id).orElse(null)
}

```

코드 양이 절반이다. 토큰도 절반이다. 비용도 절반이다.

특히 서버리스 환경에서 작은 인스턴스를 활용하여 scale-out 가능한 형태로 개발하는 게 유리한데 JVM 같은 경우 기본적인 서버의 사양이 Node.js, Python, Go 같은 언어에 대비하여 높다. 비용을 최소화하는 서비스 구조가 경쟁력을 가지는 시대가 되었다.

Java를 사용하면 동일한 서비스를 만드는 데 있어서 token 비용뿐 아니라 코드를 작성하는 시간도 동일하게 늘어나고 버그의 양도 코드 양 대비로 늘어날 수밖에 없으며 null pointer exception 같은 처리를 피하는 optional 변수를 사용하는 것도 불가능하기에 이점보다는 단점이 너무 많다. Java 개발자들은 바이브 코딩 시대에 살아남으려면 최소한 Kotlin을 빨리 익혀야 할 것이다.

## 실전 팁들: 내가 겪은 시행착오

### 1. 프롬프트는 구체적으로, 하지만 너무 길지 않게

처음에는 프롬프트를 A4 한 장 분량으로 작성하는 실수를 하기 쉽다. 결과는? AI가 중간부터는 무시한다. 핵심만 간단명료하게 작성하는 것이 효과적이다.

나쁜 예: "사용자가 로그인할 수 있는 폼을 만들어주는데, 이메일과 비밀번호를 입력받고, 유효성 검사도 하고, 에러 메시지도 보여주고, 로딩 상태도 표시하고, 성공하면 대시보드로 리다이렉트하고..."

좋은 예: "Create login form with email/password validation, error handling, loading state. Redirect to /dashboard on success. Use Supabase auth."

### 2. 작은 단위로 쪼개서 작업하라

한 번에 전체 애플리케이션을 만들려고 하지 않는 것이 중요하다. 효과적인 접근 방법:

- 먼저 라우팅 구조만 잡는다
- 그다음 레이아웃을 만든다
- 인증 기능을 추가한다
- 데이터베이스 스키마를 설계한다
- CRUD 기능을 하나씩 추가한다
- UI를 다듬는다

각 단계마다 커밋하고, 문제가 생기면 이전 단계로 돌아간다.

### 3. AI가 만든 코드를 무조건 믿지 마라

AI는 가끔 헛소리를 한다. 특히 최신 버전의 라이브러리를 쓸 때 그렇다. Supabase의 auth에서 getUser 함수보다 getClaims 함수를 사용하는 게 100배가 빠른데 AI는 계속 getUser로 코드를 생성했다.

항상 공식 문서를 확인하라. AI가 만든 코드가 실제로 동작하는지 테스트하라. 특히 보안 관련 코드는 더욱 신중하게 검토하라.

### 4. Context를 잘 관리하라

Cursor의 .cursorrules 파일이나 Claude의 프로젝트 지침을 잘 활용하라. 매번 같은 설명을 반복하지 않아도 된다.

효과적인 .cursorrules 예시:

```
Project: E-commerce SaaS Platform
Stack: Next.js 14, TypeScript, Tailwind, Supabase
Patterns: 
- Use server components by default
- Client components only for interactivity  
- All API calls through server actions
- Use Zod for validation
- Error boundaries for all pages

```

### 5. 버전 관리는 필수다

AI와 작업할 때는 더욱 그렇다. 자주 커밋하고, 브랜치를 적극 활용하라. AI가 엉망으로 만들어놓은 코드를 되돌리기 위해서다.

효과적인 브랜치 관리 전략:

- main: 프로덕션 코드
- develop: 개발 중인 코드
- feature/ai-: AI와 실험 중인 코드
- backup/date: 주요 시점의 백업

## 미래는 이미 와있다, 단지 널리 퍼지지 않았을 뿐

이미 세상은 변했다. 이 변화의 핵심이 AI이고 AI를 만들었더니 만든 나부터 대체하게 생긴 게 지금의 우리 세상이다. 이를 직시하고 발빠르게 움직여야 한다. 우리가 만든 AI에게서 우리가 죽는 일은 없어야 하지 않는가?

2025년 현재, 관찰되는 현실은 이렇다:

- 많은 스타트업이 개발팀 규모를 30-50% 줄이고 있다
- 대신 AI 도구 비용에 월 수백만 원을 투자한다
- 숙련된 1인 개발자가 대규모 팀과 경쟁 가능한 사례가 증가
- MVP 개발 기간이 크게 단축 (일부 프로젝트는 6개월→2주)
- 코드 품질이 표준화되고 일관성이 향상

하지만 아직도 많은 개발자들이 거부하고 있다. "AI가 만든 코드는 쓰레기야", "진짜 개발자는 직접 코딩해야지", "AI는 창의적인 문제를 못 풀어" 같은 말들을 한다.

19세기 러다이트 운동가들과 뭐가 다른가? 그들도 자신들이 옳다고 믿었다. 하지만 역사는 그들을 기억하지 않는다. 기계와 함께 일하는 법을 배운 사람들만 살아남았다.

## 개발자로서 살아남기 위한 전략

### 1. AI를 동료로 받아들여라

AI는 도구가 아니라 동료다. 페어 프로그래밍하듯 대화하라. 코드 리뷰를 요청하라. 더 나은 방법을 물어보라.

효과적인 AI 활용법: 혼자 코딩하지 말고 항상 AI와 함께하라. "이 코드 어떻게 개선할 수 있을까?", "더 효율적인 방법 있어?", "이 버그 왜 생긴 거 같아?" 계속 묻고 대화하는 것이 중요하다.

### 2. 새로운 역할을 정의하라

코드를 작성하는 개발자에서 시스템을 설계하는 아키텍트로 진화하라. AI는 구현은 잘하지만 큰 그림을 그리는 건 못한다. 비즈니스 요구사항을 이해하고 기술적 결정을 내리는 건 여전히 인간의 영역이다.

### 3. 도메인 지식을 쌓아라

AI는 일반적인 코딩은 잘한다. 하지만 특정 도메인의 깊은 지식을 찾는 방법을 알아서 생각하지 못한다. 도메인 지식을 사람이 쌓아놔야 AI와 대화를 통하여 지식의 깊이를 파야 한다. 금융, 의료, 물류 등 특정 분야의 전문가가 되라. AI와 도메인 지식을 결합하면 엄청난 시너지가 난다.

### 4. 커뮤니케이션 능력을 키워라

AI 시대에는 기술적 능력만큼 소통 능력이 중요하다. 비개발자와 소통하고, 요구사항을 정확히 파악하고, AI에게 명확히 전달하는 능력. 이게 핵심이다.

## 마무리하며

변화는 이미 시작됐다. 거부할 수도 있고 받아들일 수도 있다. 하지만 역사가 증명하듯, 변화를 받아들이고 적응한 사람만이 살아남는다.

나는 20년 넘게 개발을 해왔고, 지금이 가장 흥미로운 시기라고 생각한다. 더 이상 보일러플레이트 코드를 작성하는 데 시간을 낭비하지 않아도 된다. 진짜 창의적인 문제 해결에 집중할 수 있다. 더 많은 아이디어를 더 빠르게 실현할 수 있다.

물론 두렵기도 하다. 내 일자리가 사라질까 봐. 하지만 더 큰 두려움은 시대에 뒤처지는 것이다. 그래서 나는 매일 새로운 AI 도구를 실험하고, 새로운 방법을 시도하고, 계속 학습한다.

동료 개발자들에게 말하고 싶다. 두려워하지 말고 도전하라. AI는 우리를 대체하는 게 아니라 우리를 더 강하게 만든다. 단, AI를 활용할 줄 아는 개발자만 그렇다는 것을 잊지 마라.

우리가 만든 AI에게 우리가 대체되는 아이러니한 상황. 하지만 이것도 결국 인류 역사의 한 페이지일 뿐이다. 중요한 건 우리가 어떻게 적응하고 진화하느냐다.

나는 선택했다. AI와 함께 가기로. 당신의 선택은 무엇인가?